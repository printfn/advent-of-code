let data =
`#.####################################################################################################
#>^v<><>.<<<^>v>^v<v^<>v<>^<v>><v<<^.v.v.v<v^>^<>v^^>^^^^v>v<^>.v.<<^.v^>><.>><^v^^v^v>><.v>.<v<<>.><#
#<.<<<<v<<<>v^v^><v>>>>v>^>v.^v><^><>^<><><v<<.v<>^<^^v<vv^<v><^^vvv<<<..<v<><^v><<>><.<<v.v<vv>^^^^>#
#<>>.v^^<^<.v><^^^v>.<.v^<>v>>^v^<^<^>>v><<^<<v.v>^><v>v.><<><<^v<<^>.vv<>^^v<>v^v<<.^^v^v>><<>^<<>><#
#>..v<><^v<>.>>>.^<.^^v<v>v>v<v^^>><<v>^>vv^>>><^^<v<v<<v^^<>^^>^<v><<vvvv>>>vv>^><><^^^^<<.v.<^<^>>.#
#<<^>v^>^<<>v<^.v<^>.><v^v<v>>^><><<^<^>vv><>>.<><.v<^<>.<.<>>v^v.>^^>^..<<^<>^<<<>>..>^.<^^v>>>>v^^>#
#>v^^^v>^vvv<<v^^<v>^<vv<^^v<<>>v<>vvv<v>>v.>^vvv><v>v>v<<<vv><^^.^^>^.<v.^<.>v>v><vv>><^^<^>^^v<><<>#
#<>.v^>><<<vv<^>^><<.<.<.<>v>.>^^^<>.<v<>.<<<><v<><>><^.vv>><<^^>.<^.>>.<>^^..<<^.v.<>v^>>.v^<>^v<^<<#
#<>>><>><<><>^.<<><<v^.vv><v<<<v<v^^v<v>^.^<>><^>^^.^>><^^<<^>^v<^.>^.<>^>>v^vv<>..<><>^><>v.<>v><<^.#
#>>>>>v^<^^.<^v><^.v>v^<>>v>>>>.v^<><<<>>^v^v<.v<.<<v>^><.v^vv.<v.v.<<>>v<v^<>.v^>v.>v^.^^^vv>^v><>><#
#<..^>v<<^v<<<<.>vvvv<..v>^vv>^<<<.v<>vvvvv><<^>^<><^^^>>.^><vv><^>v>vv><.>^^v>>^><<>^.<<<^><^v<v>>v>#
#><vv>>v..<<..vv<v^.v.><>vv^>v<vvvv^v<>^<<><>^v><>^v^v<><^.^>^>.>><vvv<v>>v<v<v<><<<vv^<<<^>vv>.^^<v<#
#>^<v<.^<>.<<<<^<<^>>^>^v<<..>v<v^><^<v.<.v<>^<v>v.>vv^v<^vvv^vv>^v.^<.<^<>v>^<^<^^<^>v>v<^v^>>v<<<.>#
#.<^v>^.^v^>>>vv<>v<v.vv<<v><^v<>>v^<^v<>v^.><^>.>>^><^>><>..><.><<<>>^><.v>.<.^>^><>>>v^^v<^<^>><<<<#
#><<>^><<v.<>.^vv>.^^^<<<>vvv.<.<>^^<<v.^v.><>^<>v<^v^<<>v>>^.v.><v^v<v>^<<^v^>>>v<vv<^<v^<>vv.v.>vv<#
#.v.<^^<^<^<^<^<.v^>^<>><.<>^^<<^^.^.<.^>>v><<>^<^>>>><^.>.vv<>v.vv<v^.v^<^<>^v><>>>^>>.^vv><v.>^><>>#
#><v>^.^vv>v<<v^v.<vv^<^^>.vv>.<^>.^<.^>v>>v^>v^>.>.><>>v^^^><>.<>>.^v<<^<<><v<^^^<<>><^><v^<>><>^^^>#
#<v<^>vv><<>^<<>>^><^^vv>>.>.>^><vv^^><>>v>^^.v<<<<><v^><>>v^^^<<^v^>>>^<>v^^<v^<>^v><v<<<>>>v><><<v>#
#>>>^<<^v<>>>v^v^v^^^^<<<<v<<>vv>.^v<<.v^^<v<>>vvv.>>^<>v>^v^v><.^v>^<>v<<.<^^^<vv^^^^vv<v>^>^<<..^v>#
#<v<.vvv.>v^>>v>>.^<<v.^^><>^<v^>vv<<^><><<>^vv^v<>v<><v>.v^>..<>^>>v>^<vv><>>^^v<.<>>.>v<vv>>^>v<^>>#
#.vv^>^v<vv>v>.v^<>^>^.^<>^><<^<.^>v^v><<><<<^<^<>v>v>v<.^>.>^^<v.<<<v^>v^v^<<>>>v>^>^.>^<>^<^^^>vv^<#
#<<.<^v^v>v<v^<<.v..v^>>>>v>.>><<<<.vvv>vv>>^v<><<^<<<vv.^>^^vv.><v^^>^>vv>v.^vvv<<.^<..<<.<<^<..<.>>#
#<<>^^v><<v>^vv.<v^>^.^<v>.>vv^v><vv^.^.vv>v<vv><v>^v^^>^^>v<<^<v><<.vv<<>.^v<>v^>^^v^^^<v<^.v^>vvv^>#
#<.v>>v^><<^>^v^>^<>v.<v^.>.^v^<.^>v<>^<><>^>>^>^^<<^.>>v<.^v^.^vv><.<<v^v<v><>^^<>>^v<<><>.^v<<><>>>#
#<>vv<v>>v>><.>>v.<<v.v^vv^.<<<><vv>.>^^vvv^vv><>^>^v^<>><>>v<>>>>>v^><<^<.^<<<^>>^^.<>>.<<>v^v><><><#
#<^^^v<..^.<^v<^v<v>vv>>vv..^vvvv<v.^v>><>^><<^><^v.<><>>^>>v>v^>.v><>^v>^^<<<^v^.<v.>><>>>.>>>v>v>^>#
#>>vv^.<<vv.v<v>>v^^<<vv^.<>.v>>>><><.v^^v^^v.><>^^v<^v^v<.>^vv>.vvv>><v.v>><v>^>v<^.>^><<>v><<>>.>v<#
#>vv>^<<^>^<<>^>v<>^<<^><^^<^.<v<^>vvvv^<<>>v<<.<>v.^>..vvv<>v<><<<^v>v>^><^v>>^>.^>v^v<v<^<^<><^<vv>#
#><<v^vv^>>vv<>^v>>^^.<<<v>.v.>^v<<v<^<v><<vvvv.>>v.v^vv<<><<>^>>.>^v^v>vvv<..v>>v<^<>v>v<^>^>v>><.>>#
#>v<<^v^<^v<^<<>vv^vv><v><<<^><>>v<v>^^<<>.^<>>>^<v>^..<^^v<<<><>v<^^v.>vv^v^^v<v>vv<^><><^<v<^^<^<v<#
#><^.^<v>>>vv<.<>>.>v^<^><>v<v<><><vv<v.^^^<>^<<<vv.vv<>v<v^><^<>>v^>^v^>>v>v^vvvv<v^^^>.^<><v^<v^.<>#
#<^v<^<.v^<.>>^><<<^v<...<v.^>>v<^v.><><>v.>><.>v>v^..<^^^>>>>>v^.<<>^<.>^<>><^>>>^<>>^^^>v.>^vvv.^>>#
#>^>v^^.<v<>>>.v^<^v<<.><<^<><^v<>^<<^.^<<vv^.><><vv<v^^>>^>.v>v<>v>^.^<>^<>>>><<.><<>.^>>vv^><vv>>>>#
#<<.>..^^vvvv>>.v<.^^>v<^<v><<^<^.<^>^.v^><v>^...^^.><.<^<v.v>vv.<<^<>.><.<^>^>><<>.^v<^^v^>.<^v^v>><#
#<^><v^v^>v^<v^^>vv^^<v<>v<>>><v>v^^^v<^v<^>.^^><>v.<<^vvv.v>^>^<vv<v><^>vv<>v<<<^vv^<^>>^.<^>^v.<<<>#
#<>v.^.>vv^.v<^<^vvv<v^^v<>>v<<v^>><>>v<><v^>^^vv><>^<v><>v^>^>>><vv<<>v^>v>^<<^^<>.^<<^>vvvvv>^^.>^.#
####################################################################################################.#`.split('\n').map(e => e.split(''));

// data = `#E######
// #>>.<^<#
// #.<..<<#
// #>v.><>#
// #<^v^^>#
// ######.#`.split('\n').map(e => e.split(''));

import astar from 'a-star';

// function that returns the minimum cost and path to reach Finish
const dijkstra = (graph) => {
    class Node {
        constructor(value, priority) {
            this.value = value
            this.priority = priority
        }
    }

    class PriorityQueue{
        constructor(){
            this.values = []
        }

        // helper method that swaps the values and two indexes of an array
        swap(index1, index2){
            let temp = this.values[index1];
            this.values[index1] = this.values[index2];
            this.values[index2] = temp;
            return this.values;
        }
        // helper methods that bubbles up values from end
        bubbleUp(){
            //get index of inserted element
            let index = this.values.length - 1
            //loop while index is not 0 or element no loger needs to bubble
            while(index > 0){
                //get parent index via formula
                let parentIndex = Math.floor((index - 1)/2);
                //if values is greater than parent, swap the two
                if(this.values[parentIndex].priority > this.values[index].priority){
                    //swap with helper method
                    this.swap(index, parentIndex);
                    //change current index to parent index
                    index = parentIndex;
                } else{
                    break;
                }
            }
            return 0;
        }

        // method that pushes new value onto the end and calls the bubble helper
        enqueue(value, priority) {
            this.values.push(new Node(value, priority));
            // calculate parent, if parent is greater swap
            // while loop or recurse
            this.bubbleUp();
            return this.values;
        }

        bubbleDown() {
            let parentIndex = 0;
            const length = this.values.length;
            const elementPriority = this.values[0].priority;
            //loop breaks if no swaps are needed
            while (true) {
                //get indexes of child elements by following formula
                let leftChildIndex = (2 * parentIndex) + 1;
                let rightChildIndex = (2 * parentIndex) + 2;
                let leftChildPriority, rightChildPriority;
                let indexToSwap = null;
                // if left child exists, and is greater than the element, plan to swap with the left child index
                if(leftChildIndex < length){
                    leftChildPriority = this.values[leftChildIndex].priority
                    if(leftChildPriority < elementPriority){
                        indexToSwap = leftChildIndex;
                    }
                }
                //if right child exists
                if(rightChildIndex < length){
                    rightChildPriority = this.values[rightChildIndex].priority

                    if(
                        //if right child is greater than element and there are no plans to swap
                        (rightChildPriority < elementPriority && indexToSwap === null) ||
                        //OR if right child is greater than left child and there ARE plans to swap
                        (rightChildPriority < leftChildPriority && indexToSwap !== null))
                    {
                        //plan to swap with the right child
                        indexToSwap = rightChildIndex
                    }
                }
                //if there are no plans to swap, break out of the loop
                if(indexToSwap === null){
                    break;
                } 
                //swap with planned element
                this.swap(parentIndex, indexToSwap);
                //starting index is now index that we swapped with
                parentIndex = indexToSwap;
            }  
        }

        dequeue() {
            //swap first and last element
            this.swap(0, this.values.length - 1);
            //pop max value off of values
            let poppedNode = this.values.pop();
            //re-adjust heap if length is greater than 1
            if(this.values.length > 1){
                this.bubbleDown();
            }
            
            return poppedNode;
        }
    }

    const lowestCostNode = (costs, processed) => {
        return Object.keys(costs).reduce((lowest, node) => {
            if (lowest === null || costs[node] < costs[lowest]) {
                if (!processed.includes(node)) {
                    lowest = node;
                }
            }
            return lowest;
        }, null);
    };

    // track lowest cost to reach each node
    //const costs = Object.assign({finish: Infinity}, graph.start);
    const costs = new PriorityQueue();
    costs.enqueue('finish', Infinity);
    for (let v in graph.start) {
        costs.enqueue(v, graph.start[v]);
    }

    // track paths
    const parents = {finish: null};
    for (let child in graph.start) {
        parents[child] = 'start';
    }

    // track nodes that have already been processed
    // const processed = [];

    let node = costs.dequeue();//lowestCostNode(costs, processed);

    while (node) {
        let cost = costs[node];
        let children = graph[node];
        for (let n in children) {
            let newCost = cost + children[n];
            if (!costs[n]) {
                costs[n] = newCost;
                parents[n] = node;
            }
            if (costs[n] > newCost) {
                costs[n] = newCost;
                parents[n] = node;
            }
        }
        processed.push(node);
        node = lowestCostNode(costs, processed);
    }

    let optimalPath = ['finish'];
    let parent = parents.finish;
    while (parent) {
        optimalPath.push(parent);
        parent = parents[parent];
    }
    optimalPath.reverse();

    const results = {
        distance: costs.finish,
        path: optimalPath
    };

    return results;
};

function draw2d(img) {
    for (let i = 0; i < img.length; ++i) {
        let row = '';
        for (let j = 0; j < img[i].length; ++j) {
            row += img[i][j];
        }
        console.log(row);
    }
}

function gcd2(a, b) {
    // Greatest common divisor of 2 integers
    if(!b) return b===0 ? a : NaN;
    return gcd2(b, a%b);
}
function gcd(array) {
    // Greatest common divisor of a list of integers
    var n = 0;
    for(var i=0; i<array.length; ++i)
        n = gcd2(array[i], n);
    return n;
}
function lcm2(a, b) {
    // Least common multiple of 2 integers
    return a*b / gcd2(a, b);
}
function lcm(array) {
    // Least common multiple of a list of integers
    var n = 1;
    for(var i=0; i<array.length; ++i)
        n = lcm2(array[i], n);
    return n;
}

let timemod = lcm2(data.length - 2, data[0].length - 2);

function zigzag(start, time, min, max, dir = 1) {
    return (start - min + dir * time + timemod) % (max - min + 1) + min;
    // let res = start;
    // for (let i = 0; i < time; ++i) {
    //     if (res == max && dir == 1) res = min;
    //     else if (res == min && dir == -1) res = max;
    //     else res += dir;
    // }
    // let n = (start - min + dir * time + timemod) % (max - min + 1) + min;
    // if (res != n) {
    //     throw new Error(`${res} != ${n}`);
    // }
    // return res;
}

function parseData(data) {
    let tornados = [];
    for (let i = 0; i < data.length; ++i) {
        for (let j = 0; j < data[0].length; ++j) {
            let ch = data[i][j];
            if (ch == '>' || ch == '<' || ch == '^' || ch == 'v') {
                tornados.push({ i, j, dir: ch });
            }
        }
    }
    return tornados;
}

let tornados = parseData(data);

function occupied(i, j, time) {
    if (i == 0 || j == 0 || i == data.length - 1 || j == data[0].length - 1) {
        if (i == 0 && j == 1)
            return false;
        if (i == data.length - 1 && j == data[0].length - 2)
            return false;
        return true;
    }
    for (let tornado of tornados) {
        if (tornado.dir == '<' || tornado.dir == '>') {
            if (tornado.i != i) continue;
            if (zigzag(tornado.j, time, 1, data[0].length - 2, tornado.dir == '>' ? 1 : -1) != j)
                continue;
            return true;
        } else if (tornado.dir == '^' || tornado.dir == 'v') {
            if (tornado.j != j) continue;
            if (zigzag(tornado.i, time, 1, data.length - 2, tornado.dir == 'v' ? 1 : -1) != i)
                continue;
            return true;
        }
    }
    return false;
}

// function heuristic(n) {
//     let [_, x, y] = n.split(',').map(e => parseInt(e));
//     return Math.abs(x - (data.length - 2)) + Math.abs(y - (data[0].length - 2));
// }

// console.log('heuristic:', heuristic(`69,1,1`));

let occupiedmap = [];
for (let time = 0; time < timemod; ++time) {
    let r = [];
    for (let i = 0; i < data.length; ++i) {
        let line = [];
        for (let j = 0; j < data[0].length; ++j) {
            if (occupied(i, j, time)) line.push(true);
            else line.push(false);
        }
        r.push(line);
    }
    // console.log(time);
    occupiedmap.push(r);
}

// console.log('running A*');

// console.log(grid);
let first = astar({
    start: [0,0,1],
    isEnd: ([_, i, j]) => i == data.length - 1 && j == data[0].length - 2,
    neighbor: ([t, i, j]) => {
        let T = (t + 1) % timemod;
        let res = [];
        if (!occupiedmap[T][i][j])
            res.push([T,i,j]);
        if (i < data.length - 2 && !occupiedmap[T][i+1][j])
            res.push([T,i+1,j]);
        if (i > 1 && !occupiedmap[T][i-1][j])
            res.push([T,i-1,j]);
        if (j < data[0].length - 2 && !occupiedmap[T][i][j+1])
            res.push([T,i,j+1]);
        if (j > 1 && !occupiedmap[T][i][j-1])
            res.push([T,i,j-1]);
        if (i == data.length - 2 && j == data[0].length[0] - 2)
            res.push([T,i+1,j]);
        return res;
    },
    distance: (a, b) => 1,
    heuristic: ([_, i, j]) => Math.abs(i - (data.length - 1)) + Math.abs(j - (data[0].length - 2)),
});
console.log(first.cost + 1);

function heuristic([g, _, i, j]) {
    let m = data.length - 1 + data[0].length - 1;
    let d = Math.abs(i - (data.length - 1)) + Math.abs(j - (data[0].length - 2));
    if (g == 2)
        return d;
    if (g == 1)
        return m + (m - d);
    if (g == 0)
        return 2 * m + d;
}

let second = astar({
    start: [0,0,0,1],
    isEnd: ([g, _, i, j]) => g == 2 && i == data.length - 1 && j == data[0].length - 2,
    neighbor: ([g, t, i, j]) => {
        let T = (t + 1) % timemod;
        let res = [];
        if (!occupiedmap[T][i][j])
            res.push([g,T,i,j]);
        if (i < data.length - 2 && !occupiedmap[T][i+1][j])
            res.push([g,T,i+1,j]);
        if (i > 1 && !occupiedmap[T][i-1][j])
            res.push([g,T,i-1,j]);
        if (j < data[0].length - 2 && !occupiedmap[T][i][j+1])
            res.push([g,T,i,j+1]);
        if (j > 1 && !occupiedmap[T][i][j-1])
            res.push([g,T,i,j-1]);
        if (g == 0 && i == data.length - 2 && j == data[0].length - 2)
            res.push([1,T,i+1,j]);
        if (g == 1 && i == 1 && j == 1)
            res.push([2,T,i-1,j]);
        if (g == 2 && i == data.length - 2 && j == data[0].length - 2)
            res.push([2,T,i+1,j]);
        return res;
    },
    distance: (a, b) => 1,
    heuristic,
});

console.log(second.cost);
// for (let n of second.path) {
//     console.log(n, heuristic(n));
// }
